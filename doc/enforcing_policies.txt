################################################################################
The following content describes the policies enforcement steps
  After the virtual composition is performed 2 classifiers are generated :
    - one for edge_policies
    - one for fabric_policies
    The rules stored in these classifiers must be pushed to the controller
      through the REST API
################################################################################


Architectures
------------

  Logical
                    H1 ---- E1 --------- FAB ---------- E2 ------ H2

  Physical
                    H1 ---- s1 ----- s2 ----- s3 ------ s4 ------ H2

Data Structures
---------------

  + topology_graph (graph Object)
      -->  representation of the physical topology
           hwAddrs here are replaced by symbolic names (H1...)

  + physical_switches_classifiers (dictionary Object)
      --> 's1' : [list of rules]
          's2' : [...]
          ...
  + fabrics_flows_routing_table (dictionary Object)
      --> 'Fab1' : [list of routes]
          'Fab2' : [...]
          ...

Enforcement Steps
-----------------

  Step 1 : Instantiate a per physical switch classifier and a per fabric routing table

    Physical_switches_classifiers data structure will store physical rules for each switches

      --> {'s1':[],'s2':[],'s3':[],'s4':[]}

    fabrics_flows_routing_table data structure will store route between fabrics switches

      --> {'Fab':[]} (there is only one fabric here)

  Step 2 : Convert Edge Policies

    After virtual composition, one classifier is generated for all edge rules
    Each edge rule in this classifier is separatly enforced

    An edge rule can be :

      + an egress rule : rule destination is an host or a network
                         symbolic name in the rule destination field is replaced by ipAddr
                         the rule edge field is removed



      + an ingress rule :rule destination is a switch
                         the rule edge field is removed


      + a drop rule : the rule edge field is removed

      + a dataFunction rule : see dataFunction_Howto.txt

      + a NetworkFunction rule : see netFunction_Howto.txt

    From here, in physical_switches_classifiers :

      --> {'s1':[phy_rule1,phy_rule2...],'s2':[],'s3':[],'s4':{phy_rule1,phy_rule2...}}

  Step 3 : Convert Fabric Policies

    Get all rules attached to FAB

      E.G. :
          f1 = catch(fabric=Fab,src=E1,flow=IN) >> carry(E2)

    Get the physical switches mapped with the carry edge field

      E.G. : E2 --> s4

    Get all couples "match,src" for flows with label IN entering in FAB

      E.G. : match(dst=H2),s1

    Get all egress rules for each egress switches

      E.G. : match(src=H1,dst=H2) >> identity >> forward(H2)
           ....

    Install a route if there is an intersection between the match,src couple and an egress rules

      E.G. : match (dst=H2) intersect match(src=H1,dst=H2)

              --> Install a route : Fab, intersec_match, s1, s4, via_list(DM)

      When an edge is mapped to 2 switches, this allows to install rules only on the appropriate switches

    From there, the routing table may be optimized because rules which contains hosts destination can, in some
    cases be regrouped in one rule with network destination

    The SPF is run then on fabrics_flows_routing_table and fabric rules are generated after that in physical_switches_classifiers

      --> {'s1':[phy_rule1,phy_rule2...],'s2':[phy_rule1,phy_rule2...],'s3':[phy_rule1,phy_rule2...],'s4':{phy_rule1,phy_rule2...}}
