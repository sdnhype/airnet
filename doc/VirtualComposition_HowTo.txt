################################################################################
The following content describes the virtual composition steps
  Indeed, during the runtime module start, sequential and parallel
    compositions are used to combine high-level policies in order to create
      control rules which will be stored in classifiers

################################################################################


Architecture
------------

                         control_program              mapping_program
                                        \            /
                                         \          /
                                          ----------
                                              |
                                         main_program
                                              |
                                          ----------
                                        /           \
                                       /             \
                         runtime_module               infra_module



Files
-----

  + control_program --> contains high-level policies and virtual topology

  * mapping_program --> associates virtual topology elements with physical equipments



Policies Composition
--------------------

  * Sequential Composition (>>)
    ---------------------------
      "pol_1 >> pol_2" --> pol_2 will be applied to the packets returned by pol_1


  * Parallel Composition (+)
    ------------------------
      "pol_1 + pol_2"  --> execution order between pol_1 and pol_2 doesn't matter


Control Program Content
-----------------------

  The control program contents a dictionary with 3 keys ; virtual_topology, edge_policies, fabric_policies

  virtual_topology the virtual topology which is mapped to the physical architecture in the mapping program
  edge_policies and fabric_policies represents the distribution and transport high-level policies

  + Virtual Topology
    ----------------
      virtual topology description is out the purpose of this document

  + Edge Policies
    -------------
      describes the combineation of dristribution and access policies

        sequential composition of match, tag, actions (forward, modify...) policies
          --> e1 = match(flow1) >> tag(label1) >> [action1a,action1b]

        parallel composition of rules
          --> e1 + e2

        mix of sequential and parallel composition
          --> e = (match(flow1) + match(flow2)) >> tag(label) >> (action1 + action2)

              match(flow1)+match(flow2) = intersection between flow1 and flow2
              (match(flow1) + match(flow2)) >> tag(label) = sequentialComposition
              (action1 + action2) = parallelComposition

  + Fabric Policies
    -------------
      describes the transport Policies
      The principles are the same as those described earlier in the Edge Policies section

      Here, the distribution policies (match, tag) are replaced by transport policies (catch, carry)


Runtime Start --> Policies compilation
--------------------------------------

  Step 1 : Get control_program dictionary

        "virtual_topology" : language.VTOPOlogy Object
        "edge_policies"    : language.ParallelComposition or language.SequentialComposition Object
        "fabric_policies"  : language.ParallelComposition or language.SequentialComposition Object


  Step 2 : Compile Edge_policies

    * Edge_policies as a SequentialComposition object

        SequentialComposition inherits CompositionPolicy which inherits EdgePolicy which inherits Policy

        SequentialComposition Object format --> pol_1 >> pol_2 >> pol_3 >>...

        Compile a sequentialComposition object means compile each one of its policies

        Compile a policy return a classifier in which at least one rule is stored

        E.G.: e = match(....) >> tag(...) >> [action1]

          e.compile() --> match.compile() >> tag.compile() >> action.compile()

            match.compile() --> returns a classifier with at least two rules
                                r1 = Rule(match(...),identity,set[identity])
                                r2 = Rule(identity,identity,set[]) # drop rule

            tag.compile()   --> returns a classifier with one rule
                                r1 = Rule(identity,flow=="...",set[identity])

            action.compile()--> returns a classifier with one rule at least
                                r1 = Rule(identity,identity,set[action1])

            The compilation generates 3 classifiers which will be combined through the >> operator
            The SequentialComposition operator (>>) used here is redefined in Classifier class (__rshift__)

            The rshift operation applied in this example generates a classifier with two full rules

            r1 = Rule(match(...),flow=="...",set[action1])
            r2 = identity, identity, set[]


    * Edge_policies as a ParallelComposition object

      ParallelComposition inherits CompositionPolicy which inherits EdgePolicy which inherits Policy

      ParallelComposition Object format --> pol_1 + pol_2 + pol_3 +...

      ParallelComposition can be applied on :

        -- basic policies --> match (A) + match (B) returns the intersection between A and B
                          --> tag (A) + tag (B) returns the more specific label
                          --> forward(B) + DynamicPolicy() means the order of execution doesn't matter

        -- full rules --> r1 + r2 means the order of execution doesn't matter
                          r1 or r2 can be a SequentialComposition object

      Compile a parallelComposition means compile each one of its policies

      E.G. : e1 = match(F1) >> tag(F1) >> action1
             e2 = match(F2) >> tag(F2) >> action2
             return e1 + e2

        (e1 + e2) is a ParallelComposition object with e1 and e2 SequentialComposition objects

        (e1 + e2).compile() --> (e1.compile() + e2.compile())

          After e1.compile() we have in classifier C1 :
            r1a = Rule(match(F1),flow=="F1",set[action1])
            r1b = identity, identity, set[]

          After e2.compile() we have in classifier C2 :
            r2a = Rule(match(F2),flow=="F2",set[action2])
            r2b = identity, identity, set[]

          The ParallelComposition generates 2 classifiers which will be combined through the + operator
          The ParallelComposition operator (+) used here is redefined in the Classifier class (__add__)

          The ParallelComposition of these C1 and C2 generates :

            -- 3 rules if there is no intersection between F1 and F2

                r1 = Rule(match(F1),flow=="F1",set[action1])
                r2 = Rule(match(F2),flow=="F2",set[action2])
                r3 = identity, identity, set[]

            -- 4 rules if there is an intersection between F1 and F2

                r0 = Rule(match(F'),flow=="F'",set[action'])
                r1 = Rule(match(F1),flow=="F1",set[action1])
                r2 = Rule(match(F2),flow=="F2",set[action2])
                r3 = identity, identity, set[]

                r0 is the rule for the intersection flow F' between F1 and F2
                r0 has higher priority than r1 and r2
                F' is the much specific label between F1 and F2
                action' could be :
                  -- action1
                  -- action2
                  -- action1 + action2


  Step 3 : Compile Fabric_policies

    * Fabric_policies as a FabricSequentialComposition object

        FabricSequentialComposition inherits FabricCompositionPolicy which inherits FabricPolicy
        which inherits Policy

        FabricSequentialComposition Object format --> pol_1 >> pol_2 >> pol_3 >>...

        Compile a FabricsequentialComposition object means compile each one of its policies

        E.G.: f = catch(....) >> carry(...) >> [via (...)]

          e.compile() --> catch.compile() >> carry.compile() >> via.compile()

            catch.compile() --> returns a classifier with one rule
                                r1 = Rule(catch(...),{identity},list())

            carry.compile() --> returns a classifier with one rule
                                r1 = Rule(identity,{self},list[])

            via.compile()   --> returns a classifier with one rule at least
                                r1 = Rule(identity,{identity},[self])

            The compilation generates 3 classifiers which will be combined through the >> operator
            The FabricSequentialComposition operator (>>) used here is redefined in FabricClassifier
            class (__rshift__)

            The rshift operation applied in this example generates a fabric classifier with one transport rule

            r1 = FabricRule(catch(...),carry('..':[..]),[via(...)])

    * Fabric_policies as a FabricParallelComposition object

      FabricParallelComposition inherits FabricCompositionPolicy which inherits FabricPolicy
      which inherits Policy

      FabricParallelComposition Object format --> pol_1 + pol_2 + pol_3 +...

      Compile a parallelComposition means compile each one of its policies

      E.G. : f1 = catch(X1) >> carry(L1) >> via(DM1)
             f2 = catch(X2) >> carry(L2) >> []
             return f1 + f2

        (f1 + f2) is a FabricParallelComposition object with f1 and f2 FabricSequentialComposition objects

        (f1 + f2).compile() --> (f1.compile() + f2.compile())

          After f1.compile() we have in classifier C1 :
            r1 = FabricRule(catch(X1),carry(L1),[via(DM1)])

          After f2.compile() we have in classifier C2 :
            r2 = FabricRule(catch(X2),carry(L2),[])

          The FabricParallelComposition generates 2 classifiers which will be combined through the + operator
          The FabricParallelComposition operator (+) used here is redefined in the FabricClassifier class (__add__)

          The FabricParallelComposition of these C1 and C2 generates 2 rules:

            r1 = FabricRule(catch(X1),carry(L1),[via(DM1)])
            r2 = FabricRule(catch(X2),carry(L2),[])
