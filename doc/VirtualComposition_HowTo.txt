################################################################################

The following content describes the virtual composition different steps

Indeed, during the runtime module start, sequential and parallel compositions
are used to combine high-level policies in order to create control rules
which will be stored in classifiers

################################################################################


Architecture
------------

                         control_program              mapping_program
                                        \            /
                                         \          /
                                          ----------
                                              |
                                         main_program
                                              |
                                          ----------
                                        /           \
                                       /             \
                         runtime_module               infra_module



Files
-----

  + control_program --> contains high-level policies and virtual topology

  * mapping_program --> associates virtual topology elements with physical equipments



Policies Composition
--------------------

  * Sequential Composition (>>)
    ---------------------------
      "pol_1 >> pol_2" --> pol_2 will be applied to the packets returned by pol_1


  * Parallel Composition (+)
    ------------------------
      "pol_1 + pol_2"  --> execution order between pol_1 and pol_2 doesn't matter


Control Program Content
-----------------------

  The control program contents a dictionary with 3 keys ; virtual_topology, edge_policies, fabric_policies

  virtual_topology the virtual topology which is mapped to the physical architecture in the mapping program
  edge_policies and fabric_policies represents the distribution and transport high-level policies

  + Virtual Topology
    ----------------
      virtual topology description is out the purpose of this document

  + Edge Policies
    -------------
      describes the combineation of dristribution and access policies

        sequential composition of match, tag and actions policies
          --> e1 = match(flow1) >> tag(label1) >> [action1a,action1b]

        parallel composition of rules
          --> e1 + e2

        mix of sequential and parallel composition
          --> e = (match(flow1) + match(flow2)) >> tag(label) >> (action1 + action2)

              match(flow1)+match(flow2) = intersection between flow1 and flow2
              (match(flow1) + match(flow2)) >> tag(label) = sequentialComposition
              (action1 + action2) = parallelComposition

  + Fabric Policies
    -------------
      describes the transport Policies
      The principles are the same as those described earlier in the Edge Policies section

      Here, the distribution policies (match, tag) are replaced by transport policies (catch, carry)


Runtime Start --> Policies compilation
--------------------------------------

  Step 1 : Get control_program dictionary

        "virtual_topology" : language.VTOPOlogy Object
        "edge_policies"    : language.ParallelComposition or language.SequentialComposition Object
        "fabric_policies"  : language.ParallelComposition or language.SequentialComposition Object


  Step 2 : Compile Edge_policies

    * Edge_policies as a SequentialComposition object

        SequentialComposition inherits CompositionPolicy which inherits EdgePolicy which inherits Policy

        SequentialComposition Object format --> pol_1 >> pol_2 >> pol_3 >>...

        Compile a sequentialComposition object means compile each one of its policies

        Compile a policy return a classifier in which at least one rule is stored

        E.G.: e = match(....) >> tag(...) >> [action1]

          e.compile() --> match.compile() >> tag.compile() >> action.compile()

            match.compile() --> returns a classifier with at least two rules
                                r1 = Rule(match(...),identity,set[identity])
                                r2 = Rule(identity,identity,set[]) # drop rule

            tag.compile()   --> returns a classifier with one rule
                                r1 = Rule(identity,flow=="...",set[identity])

            action.compile()--> returns a classifier with one rule at least
                                r1 = Rule(identity,identity,set[action1])

            The compilation generates 3 classifiers which will be combined
            The rshift operator (>>) is used here and redefined in Classifier class

            The rshift operation applied here generates a classifier with two full rules

            r1 = Rule(match(...),flow=="...",set[action1])
            r2 = identity, identity, set[]

    * Edge_policies as a ParallelComposition object
