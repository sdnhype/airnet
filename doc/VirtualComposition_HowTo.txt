################################################################################

The following content describes the virtual composition different steps

Indeed, during the runtime module start, sequential and parallel compositions
are used to combine high-level policies in order to create control rules
which will be stored in classifiers

################################################################################


Architecture
------------

                         control_program              mapping_program
                                        \            /
                                         \          /
                                          ----------
                                              |
                                         main_program
                                              |
                                          ----------
                                        /           \
                                       /             \
                         runtime_module               infra_module



Files
-----

  + control_program --> contains high-level policies and virtual topology

  * mapping_program --> associates virtual topology elements with physical equipments



Policies Composition
--------------------

  * Sequential Composition (>>)
    ---------------------------
      "pol_1 >> pol_2" --> pol_2 will be applied to the packets returned by pol_1


  * Parallel Composition (+)
    ------------------------
      "pol_1 + pol_2"  --> execution order between pol_1 and pol_2 doesn't matter


Control Program Content
-----------------------

  The control program contents a dictionary with 3 keys ; virtual_topology, edge_policies, fabric_policies

  virtual_topology the virtual topology which is mapped to the physical architecture in the mapping program
  edge_policies and fabric_policies represents the distribution and transport high-level policies

  + Virtual Topology
    ----------------
      virtual topology description is out the purpose of this document

  + Edge Policies
    -------------
      describes the combineation of dristribution and access policies

        sequential composition of match, tag and actions policies
          --> e1 = match(flow1) >> tag(label1) >> [action1a,action1b]

        parallel composition of rules
          --> e1 + e2

        mix of sequential and parallel composition
          --> e = (match(flow1) + match(flow2)) >> tag(label) >> (action1 + action2)

              match(flow1)+match(flow2) = intersection between flow1 and flow2
              (match(flow1) + match(flow2)) >> tag(label) = sequentialComposition
              (action1 + action2) = parallelComposition

  + Fabric Policies
    -------------
      describes the transport Policies
      The principles are the same as those described earlier in the Edge Policies section

      Here, the distribution policies (match, tag) are replaced by transport policies (catch, carry)


Runtime Start --> Policies compilation
--------------------------------------

  Step 1 : Get virtual_topology and High-level policies

      toyExample_bis.py main() contains a dictionnary

        "virtual_topology" : language.VTOPOlogy Object
        "edge_policies"    : language.ParallelComposition or language.SequentialComposition Object
        "fabric_policies"  : language.ParallelComposition or language.SequentialComposition Object

        edges_policies / fabric_policies <---> distribution / transport separation


  Step 2 : Get mapping_program

      toyExample_mapping.py contains a MyMapping class

      My Mapping associate virtual_topology elements to physical_topology equipments

          self.addHostMap(HA, "10.0.0.11")


  Step 3 : Replace symbolic names by ipAddr in edge_policies

    In edge_policies match fields, src or dst are imperatively host or network addrs

    toyExample_mapping.py allows to perform the substitutions


  Step 4 : Compile Edge_policies

    Edge_Policies can be :

      - SequentialComposition Object : Policies are separated by >> operator
                                       (match (..) >> tag >> action1 )

      - ParallelComposition Object   : Policies are separated by + operator
                                       (pol_1 + pol_2)

d
    * Edge_policies as a SequentialComposition object

        PS: A -> B means B inherited from A

        Policy -> EdgePolicy -> CompositionPolicy -> SequentialComposition

        Compiling a SequentialComposition Object means compile each one of its policies

          SequentialComposition object = Pol_1 >> Pol_2 >> Pol_3 >> ...

          Each policy compilation generates a classifier which contains at least the default drop rule


          Pol_1/Pol_2/Pol_3 type can be :

            - match : pol_1.compile() generates
